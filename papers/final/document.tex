\documentclass{bioinfo}
\copyrightyear{2012}
\pubyear{2012}

\usepackage{natbib}
\bibpunct{(}{)}{;}{a}{,}{,}
\usepackage{csquotes}
\usepackage{minted}

\begin{document}
\firstpage{1}

\title[Applying Best Practices]{Applying Best Practices to BioInformatics Software}
\author[Sample \textit{et~al}]{Sean Fisk\,$^{1,*}$, Gray Gwizdz\,$^{2}$ \footnote{to whom correspondence should be addressed}}
\address{$^{1}$Grand Valley State University\\
  $^{2}$Grand Valley State University}

\history{Received on XXXXX; revised on XXXXX; accepted on XXXXX}

\editor{Associate Editor: XXXXXXX}

\maketitle

\begin{abstract}

  \section{Summary}
  CpG islands are areas of a DNA sequence rich in the nucleotides
  Cytosine and Guanine. These islands are important because they are
  often observed in the promoter regions of DNA. The goal of this
  project to develop a program to analyze and visualize DNA for CpG
  islands. When provided with a DNA sequence, the program will provide a
  graphical visualization of CpG islands within sequence.

  \section{Availability}
  The software is hosted on
  \href{https://github.com/seanfisk/cpg-islands/}{GitHub}, while
  documentation is hosted on
  \href{https://cpg-islands.readthedocs.org/en/latest/}{ReadTheDocs}. CpG
  Islands is free software licensed under the
  \href{http://www.gnu.org/licenses/gpl.html#content}{GNU General Public
    License version 3}.

  \section{Contact} \href{gwizdzg@mail.gvsu.edu}{gwizdzg@mail.gvsu.edu}, \href{fiskse@mail.gvsu.edu}{fiskse@mail.gvsu.edu}
\end{abstract}

\section{Introduction}

Finding CpG islands often serves as an introduction to programming in the health sciences. While many different implementations of programs that find CpG islands exist, it was difficult to find a valid implementation. After failing to find an suitable implementation to verify our implementation against, we decided to focus on the shortcomings of other projects. Many times there would be no source code or documentation, which prevented us from comparing our implementation to a previous paper. When comparable source code was obtainable, it was poorly maintained or unreadable. Our focus shifted to having a well tested and documented implementation of a CpG island finder, rather than just another forgotten program.
    
\section{CpG Islands}

Before discussing best practices, an introduction to CpG islands is needed. A CpG island is a portion of a genome with a large count of Cytosine nucleotides and Guanine nucleotides. CpG islands will have a much higher occurrence of Cytosine and Guanine nucleotides than other parts of the genome by their nature. A CpG is a Cytosine nucleotide followed immediately by a Guanine nucleotide. By counting the amount of CpGs and comparing them to an expected amount of CpGs based on the count of Cytosine nucleotides and Guanine nucleotides, we can determine if a portion of a sequence is a CpG island. A high observed to expected ratio is usually the most important attribute in determining if a portion of a sequence is a CpG island. The equation for calculating an observed to expected ratio for a can be seen in Figure 1.

\begin{equation}
    \textit{observed to expected} = \frac{\sum CpG}{(\frac{\sum G * \sum C}{\textit{window length}})} \label{eq:01}
\end{equation}
      
CpG islands are present in the promoter regions of approximately 40\% of mammalian genes \citep{pmid11891299}. Methylation of promoter CpG islands have been associated with many interesting genomic attributes, such as gene silencing, X-chromosome inactivation, as well as carcinogenesis. By locating CpG islands, scientists should be able spend less time mapping genes onto genomes by paying explicit attention to CpG islands when observing changes in genes.

\section{Methodology}

Test-Driven Development served as a basic methodology when designing our application. In order to add a new feature to the implementation, the first step is writing a test that described the new feature. By writing the test before adding the feature, the test is guaranteed to fail. This may seem like a problem, but it actually is quite helpful. It is often better to think about a program in terms of results, rather than how it should be designed. Once the test has been written, the new feature is added to the build to pass the test. Creating a test before writing any function may seem like overhead, but the test remains valid indefinitely. If a test breaks as a result of changes to an unrelated section of code, you will be alerted next time the test suite is ran.\\

When creating a program with a graphical user interface, there are
several different software development approaches that a developer can
take. One of the most common paradigms is a Model-View-Controller
architecture. The model holds the application logic and data, the
controller is responsible for handling input from the user, and the
view represents output from the program. While this paradigm is highly
successful, it may not be the best approach for Test-Driven
Development. A slight variation of the Model-View-Controller style,
Model-View-Presenter, focuses on facilitating unit tests. Combining
Test-Driven Development with a Model-View-Presenter design pattern
leads to a software development approach known as Presenter First. \citep{Alles:2006:PFO:1155439.1155482}\\

Presenter First has proven to be an effective technique for scaling graphical applications with Test-Driven Development. With the Presenter-First methodology, program functionality is driven by user stories. The user stories are first designed as tests for the presenter, with features to implement the user story being added to the model. New features for the model require failing tests before creation, ensuring that the minimal solution to solve the problem is written.

\subsection{Algorithms}

Choosing an algorithm to locate CGIs was a somewhat difficult
task, as there is very little agreement as to the definition of
CGIs. Two common definitions are provided. The first, defined by
Gardiner and Frommer, defines a CGI as a region of at least 200 base
pairs containing a GC ratio of at least 50\% and an observed to
expected CpG ratio of at least 0.6. The second definition, revised by
Takai and Jones, defines a CGI as a region of at least 500 base pairs containing a GC ratio of at least 55\% and an observed to
expected CpG ratio of at least 0.65 \citep{pmid11891299}.

Another algorithm which can be used to identify CGIs is called
CpGcluster. Instead of the using the traditional criteria, CpGcluster
is \textquote[\cite{pmid17038168}]{based on the physical distance
  between neighboring CpGs on the chromosome}. Han and Zhoa later
compared the relative accuracy of the Takai-Jones implementation
versus CpGcluster, and determined that Takai-Jones was more accurate
\citep{pmid19232104}. For this reason, we decided to implement the
Takai-Jones definition as well as giving the option to change the
parameters.

After settling on giving the option to choose between the
Gardiner-Frommer and Takai-Jones parameters, choosing the specific way
to implement these criteria was once again a challenge. Since CpG
islands are a commonly addressed problem, we decided to attempt to
match our results with an existing implementation. We identified a
number of tools that claimed to solve the CpG islands
problem. However, we decided that source code for the original
implementation was necessary in order to properly match the
results. We were therefore able to narrow it down to three: the
Sequence Manipulation Suite, second edition (SMS2), the European
Molecular Biology Open Software Suite (EMBOSS), and the Perl script
which accompanied and was published alongside the paper by Takai and
Jones.

\subsubsection{SMS2}

SMS2 is a \textquote[\cite{sms2}]{collection of JavaScript programs
  for generating, formatting, and analyzing short DNA and protein
  sequences}. SMS2 provided a 200 base fixed-size sliding window
implementation with accumulating counts. The fixed-size window is
different than the typical greedy window implementation in that it
will only find islands of a certain size, not greater to or equal than
that size. This is a disadvantage from a practical standpoint because
windows such as 304-504, 305-505, 306-606, etc. are rarely useful in
practice. In addition, analysis of the source code found a so-called
``of-by-one'' error in the code. When calculating the CpG count for
the first window, a CpG formed by a C inside the window and a G
outside the window was included in the window's count. The offending
code is as follows:
\pagebreak
\begin{minted}[frame=single,label=cpg\_islands.js,linenos=true]{javascript}
// ...
//determine base counts for first window
for (var i = 0; i < windowSize; i++) {
    if (dnaSequence.charAt(i) == "g") {
        numG = numG + 1;
    }
    if (dnaSequence.charAt(i) == "c") {
        numC = numC + 1;
        if (dnaSequence.charAt(i + 1)
            == "g") {
            numCG = numCG + 1;
            numG = numG + 1;
            i = i + 1;
        }
    }
}
// ...
\end{minted}

The last time through the loop, \verb|i = windowSize - 1|.
This means that in line 9,
\verb|dnaSequence.charAt(i + 1)|
retrieves a character which is \emph{outside} the window.

Given the fact that SMS2 uses fixed-size windows and errors were found
in the code, we decided not to attempt to match its results.

\section{Tools}

This project was written using the Python programming language, along with several other tools and libraries.

\begin{itemize}
\item Biopython for sequence fetching and parsing
\item Qt for graphical user interface
\item PySide for Python bindings to Qt
\item git for version control system
\item GitHub for git hosting
\item pytest test framework
\item mock for creating mock objects
\item coverage.py and pytest-cov for test-coverage statistics
\item flake8 as a lint tool: enforced pep8 compliance, running PyFlakes and McCabe complexity check
\item Travis-CI for continuous integration
\item Sphinx and docutils for documentation generation
\item Read the Docs for documentation hosting
\item shovel for running miscellaneous tasks
\end{itemize}

The combination of these tools allowed us to continuously integrate our working implementation while adding new features. By using these tools we were able to enforce strict design standards with minimal setup or logic overhead.

\paragraph{Biopython\textcolon}
      Biopython is a set of open source scientific libraries for the Python programming language \citep{pmid19304878}. Biopython is especially well suited for analyzing genetic sequences. Complex functions like sequence annotation, parsing sequence files are supported. Biopython was used in this project for sequence representation, labeling CpG islands, loading sequences from GenBank files, and interfacing with the Entrez database.\\
    
\paragraph{Qt, PySide\textcolon}
Qt is a cross-platform framework used primarily for creating graphical user interfaces. PySide is a library with bindings to the Qt framework, which allowed us to develop this program with one code base for multiple platforms.

\paragraph{git\textcolon} 
git is a distributed version control tool for source code. A user can have local branches of a code repository without affecting any other repositiories. Using this tool allowed us to add new tests and features to the program without having to share a central repository.

\paragraph{GitHub\textcolon} 
GitHub is an online software development community for hosting git repositories. Open source project hosting is free, which allowed us to make contributions to the build independently.
    
\paragraph{Travis-CI\textcolon}
Travis-CI is a continuous integration service for open source projects. Travis-CI will integrate with any GitHub repository and run a test suite to verify a build has not broken.

\paragraph{pytest\textcolon} 
pytest is a unit testing framework used to create test suites for Python programs. pytest was used to create coverage reports detailing our source code, and running the test suite.

\paragraph{flake8\textcolon} 
flake8 is a syntax checker for Python that uses the PyFlakes and pep8 modules. It will check any source files for runtime errors and ensure all code meets pep8 coding standards.
    
\paragraph{Sphinx, docutils\textcolon}
Sphinx and docutils are documentation generators which will take source code documentation and convert it into many different formats. Using these tools created our documentation while we added new code to the repository automatically.

\paragraph{Read the Docs\textcolon} 
Read the Docs is a site that will host documentation for projects. We configured our GitHub repository with a post-commit hook, which would rebuild the documentation from our source code after each change to the online repository.
      
\subsection{Entrez}

While the program is able to find CpG islands, it did not address the problem of where to obtain sequences. NCBI hosts several different databases holding genomic information, so integrating the Entrez database search into our application seemed natural. Entrez has an API for many useful functions including keyword searches, query suggestions as well as the ability to download sequence data. Biopython provides an easy interface to these functionalities, allowing us to integrate all of the sequences hosted on the Entrez nucleotide database into our program without including additional libraries. Calls are made through a simple web API, allowing users to quickly find CpG islands without having to download sequence data separately. A suggested query will update as users type, allowing them to check for spelling errors. After submitting a query to Entrez, a list of identification numbers are returned along with the boolean search query that Entrez searched. A list of numbers is not particulary helpful after searching, but other data cannot be populated until a sequence is selected. After a user selects a sequence from the list, metadata about the sequence including the locus and length is pulled from Entrez. After a user has found a sequence they would like to analyze, they simply click the load button and the sequence is loaded into the sequence input view.

\section{Conclusion}
The goal of this project was to have a well-tested, usable program for finding CpG islands. Developing a graphical-user interface is far more usable for any biologists compared to a command line version. Using a greedy algorithm to determine islands compared to a fixed window size gives a biologist better information about the island. The program has a test suite of more than 80 tests checking program functionality, and hosted documentation for functions in the program. The development methodology and focusing on best practices has made this program an incredible success.

% \bibliographystyle{natbib}
% \bibliographystyle{achemnat}
\bibliographystyle{plainnat}
% \bibliographystyle{abbrv}
% \bibliographystyle{bioinformatics}
% 
% \bibliographystyle{plain}
% 
\bibliography{citations}

\end{document}
