\documentclass{bioinfo}
\copyrightyear{2012}
\pubyear{2012}

\usepackage{natbib}
\bibpunct{(}{)}{;}{a}{,}{,}
\usepackage{csquotes}

\begin{document}
\firstpage{1}

\title[Applying Best Practices]{Applying Best Practices to BioInformatics Software}
\author[Sample \textit{et~al}]{Sean Fisk\,$^{1,*}$, Gray Gwizdz\,$^{2}$ \footnote{to whom correspondence should be addressed}}
\address{$^{1}$Grand Valley State University\\
  $^{2}$Grand Valley State University}

\history{Received on XXXXX; revised on XXXXX; accepted on XXXXX}

\editor{Associate Editor: XXXXXXX}

\maketitle

\begin{abstract}

  \section{Summary}
  CpG islands are areas of a DNA sequence rich in the nucleotides
  Cytosine and Guanine. These islands are important because they are
  often observed in the promoter regions of DNA. The goal of this
  project to develop a program to analyze and visualize DNA for CpG
  islands. When provided with a DNA sequence, the program will provide a
  graphical visualization of CpG islands within sequence.

  \section{Availability}
  The software is hosted on
  \href{https://github.com/seanfisk/cpg-islands/}{GitHub}, while
  documentation is hosted on
  \href{https://cpg-islands.readthedocs.org/en/latest/}{ReadTheDocs}. CpG
  Islands is free software licensed under the
  \href{http://www.gnu.org/licenses/gpl.html#content}{GNU General Public
    License version 3}.

  \section{Contact} \href{gwizdzg@mail.gvsu.edu}{gwizdzg@mail.gvsu.edu}, \href{fiskse@mail.gvsu.edu}{fiskse@mail.gvsu.edu}
\end{abstract}

\section{Introduction}

Finding CpG islands often serves as an introduction to programming in the health sciences. While many different implementations of programs that find CpG islands exist, it was difficult to find a valid implementation. After failing to find an suitable implementation to verify our implementation against, we decided to focus on the shortcomings of other projects. Many times there would be no source code or documentation, which prevented us from comparing our implementation to a previous paper. When comparable source code was obtainable, it was poorly maintained or unreadable. Our focus shifted to having a well tested and documented implementation of a CpG island finder, rather than just another forgotten program.
    
\section{CpG Islands}

Before discussing best practices, an introduction to CpG islands is needed. CpG islands are present in the promoter and exonic regions of approximately 40\% of mammalian genes. The locations of these CpG islands can be a great indicator of promoter regions, which assists biologists in mapping genomes.

\begin{equation}
    \textit{observed to expected} = \frac{\sum CpG}{(\frac{\sum G * \sum C}{\textit{window length}})} \label{eq:01}
\end{equation}

\section{Methodology}

Test-Driven Development served as a basic methodology when desiging our application. In order to add a new feature to the implementation, the first step is writing a test that described the new feature. By writing the test before adding the feature, the test is guaranteed to fail. This may seem like a problem, but it actually is quite helpful. It is often better to think about a program in terms of results, rather than how it should be designed. Once the test has been written, the new feature is added to the build to pass the test. Creating a test before writing any function may seem like overhead, but the test remains valid indefinitely. If a test breaks as a result of changes to an unrelated section of code, you will be alerted next time the test suite is ran.\\

When creating a program with a graphical user interface, there are
several different software development approaches that a developer can
take. One of the most common paradigms is a Model-View-Controller
architecture. The model holds the application logic and data, the
controller is responsible for handling input from the user, and the
view represents output from the program. While this paradigm is highly
successful, it may not be the best approach for Test-Driven
Development. A slight variation of the Model-View-Controller style,
Model-View-Presenter, focuses on facilitating unit tests. Combining
Test-Driven Development with a Model-View-Presenter design pattern
leads to a software development approach known as Presenter First. \citep{Alles:2006:PFO:1155439.1155482}\\

Presenter First has proven to be an effective technique for scaling graphical applications with Test-Driven Development. With the Presenter-First methodology, program functionality is driven by user stories. The user stories are first designed as tests for the presenter, with features to implement them being added to the model. New features for the model require failing tests before creation, ensuring that the minimal solution to solve the problem is written.

\subsection{Algorithms}

Choosing an algorithm to locate CGIs was a somewhat difficult
task, as there is very little agreement as to the definition of
CGIs. Two common definitions are provided. The first, defined by
Gardiner and Frommer, defines a CGI as a region of at least 200 base
pairs containing a GC ratio of at least 50\% and an observed to
expected CpG ratio of at least 0.6. The second definition, revised by
Takai and Jones, defines a CGI as a region of at least 500 base pairs containing a GC ratio of at least 55\% and an observed to
expected CpG ratio of at least 0.65 \citep{pmid11891299}.

Another algorithm which can be used to identify CGIs is called
CpGcluster. Instead of the using the traditional criteria, CpGcluster
is \textquote[\cite{pmid17038168}]{based on the physical distance
  between neighboring CpGs on the chromosome}. Han and Zhoa later
compared the relative accuracy of the Takai-Jones implementation
versus CpGcluster, and determined that Takai-Jones was more accurate
\citep{pmid19232104}. For this reason, we decided to implement the
Takai-Jones definition as well as giving the option to change the
parameters.

\section{Tools}

This project was written using the Python programming language, along with several other tools and libraries.

\begin{itemize}
\item Biopython for sequence fetching and parsing
\item Qt for graphical user interface
\item PySide for Python bindings to Qt
\item git for version control system
\item GitHub for git hosting
\item pytest test framework
\item mock for creating mock objects
\item coverage.py and pytest-cov for test-coverage statistics
\item flake8 as a lint tool: enforced pep8 compliance, running PyFlakes and McCabe complexity check
\item Travis-CI for continuous integration
\item Sphinx and docutils for documentation generation
\item Read the Docs for documentation hosting
\item shovel for running miscellaneous tasks
\end{itemize}

The combination of these tools allowed us to continuously integrate our working implementation while adding new features.

\paragraph{Biopython\textcolon}
Biopython is a set of scientific libraries for the Python programming language. Biopython is especially well suited for analyzing genetic sequences. Complex functions like sequence annotation, parsing sequence files are supported. Biopython was used in this project for sequence representation, labeling CpG islands, loading sequences from GenBank files, and searching the Entrez database for sequences.
    
\paragraph{Qt, PySide\textcolon}
Qt is a cross-platform framework used primarily for creating graphical user interfaces. PySide is a library with bindings to the Qt framework, which allowed us to develop this program with one code base for multiple platforms.

\paragraph{git\textcolon} 
git is a distributed version control tool for source code. A user can have local branches of a code repository without affecting any other repositiories. Using this tool allowed us to add new tests and features to the program without having to share a central repository.

\paragraph{GitHub\textcolon} 
GitHub is an online software development community for hosting git repositories. Open source project hosting is free, which allowed us to work on this project independently.
    
\paragraph{Travis-CI\textcolon}
Travis-CI is a continuous integration service for open source projects. Travis-CI will integrate with any GitHub repository and run a test suite to verify a build has not broken.

\paragraph{pytest\textcolon} 
pytest is a unit testing framework used to create test suites for Python programs. pytest was used to create coverage reports detailing our source code, and running the test suite.

\paragraph{flake8\textcolon} 
flake8 is a syntax checker for Python that uses the PyFlakes and pep8 modules. It will check any source files for runtime errors and ensure all code meets pep8 coding standards.
    
\paragraph{Sphinx, docutils\textcolon}
Sphinx and docutils are documentation generators which will take source code documentation and convert it into many different formats. Using these tools created our documentation while we added new code to the repository automatically.

\paragraph{Read the Docs\textcolon} 
Read the Docs is a site that will host documentation for projects. We configured our GitHub repository with a post-commit hook, which would rebuild the documentation from our source code after each change to the online repository.

\section{Results}



\section{Conclusion}

% \bibliographystyle{natbib}
% \bibliographystyle{achemnat}
\bibliographystyle{plainnat}
% \bibliographystyle{abbrv}
% \bibliographystyle{bioinformatics}
% 
% \bibliographystyle{plain}
% 
\bibliography{citations}

\end{document}
